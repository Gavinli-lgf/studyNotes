# [C++风格指南](https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/scoping/)

风格, 亦被称作可读性

## 头文件
* 头文件应该能够自给自足（self-contained,也就是可以作为第一个头文件被引入），以 .h 结尾。至于用来插入文本的文件，说到底它们并不是头文件，所以应以 .inc 结尾。不允许分离出 -inl.h 头文件的做法.
* 尽可能地避免使用前置声明。使用 #include 包含需要的头文件即可。
* 只有当函数只有 10 行甚至更少时才将其定义为内联函数.（注意：析构函数、包含循环或 switch 语句的函数。）
* #include 的路径及顺序

## 作用域
* 鼓励在 .cc 文件内使用匿名命名空间或 static 声明. 使用具名的命名空间时, 其名称可基于项目名或相对路径. 禁止使用 using 指示（using-directive）。禁止使用内联命名空间（inline namespace）。
* 在 .cc 文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为 static 。但是不要在 .h 文件中这么做。
* 使用静态成员函数或命名空间内的非成员函数, 尽量不要用裸的全局函数. 将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果，类的静态方法应当和类的实例或静态数据紧密相关.
* 将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化.(有一个例外, 如果变量是一个对象, 每次进入作用域都要调用其构造函数,每次退出作用域都要调用其析构函数. 这会导致效率降低.)
* 禁止定义静态储存周期非POD变量，禁止使用含有副作用的函数初始化POD全局变量，因为多编译单元中的静态变量执行时的构造和析构顺序是未明确的，这将导致代码的不可移植。

## 类
* 不要在构造函数中调用虚函数, 也不要在无法报出错误时进行可能失败的初始化
* 不要定义隐式类型转换. 对于转换运算符和单参数构造函数, 请使用 explicit 关键字.
* 如果你的类型需要, 就让它们支持拷贝 / 移动.否则,就把隐式产生的拷贝和移动函数禁用.
* 仅当只有数据成员时使用 struct, 其它一概使用 class.
* 使用组合 (YuleFox 注: 这一点也是 GoF 在 <<Design Patterns>> 里反复强调的) 常常比使用继承更合理. 如果使用继承的话, 定义为 public 继承.
* 真正需要用到多重实现继承的情况少之又少. 只在以下情况我们才允许多重继承: 最多只有一个基类是非抽象类; 其它基类都是以 Interface 为后缀的 纯接口类.
* 接口是指满足特定条件的类, 这些类以 Interface 为后缀 (不强制).
* 除少数特定环境外, 不要重载运算符. 也不要创建用户定义字面量.
* 将 所有 数据成员声明为 private, 除非是 static const 类型成员 (遵循 常量命名规则). 出于技术上的原因, 在使用 Google Test时我们允许测试固件类中的数据成员为 protected.
* 将相似的声明放在一起, 将 public 部分放在最前.

## 函数
* 我们倾向于按值返回， 否则按引用返回。 避免返回指针， 除非它可以为空.（在排序函数参数时， 将所有输入参数放在所有输出参数之前. 特别要注意, 在加入新参数时不要因为它们是新参数就置于参数列表最后, 而是仍然要按照前述的规则, 即将新的输入参数也置于输出参数之前.）
* 我们倾向于编写简短, 凝练的函数.
* 所有按引用传递的参数必须加上 const.（事实上这在 Google Code 是一个硬性约定: 输入参数是值参或 const 引用, 输出参数为指针. 输入参数可以是 const 指针, 但决不能是非 const 的引用参数, 除非特殊要求, 比如 swap().）
* 若要使用函数重载, 则必须能让读者一看调用点就胸有成竹, 而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数.
* 对于虚函数, 不允许使用缺省参数, 因为在虚函数中缺省参数不一定能正常工作. 如果在每个调用点缺省参数的值都有可能不同, 在这种情况下缺省函数也不允许使用. (例如, 不要写像 void f(int n = counter++); 这样的代码.)在其他情况下, 如果缺省参数对可读性的提升远远超过了以上提及的缺点的话, 可以使用缺省参数. 如果仍有疑惑, 就使用函数重载.
* 在大部分情况下, 应当继续使用以往的函数声明写法, 即将返回类型置于函数名前. 只有在必需的时候 (如 Lambda 表达式) 或者使用后置语法能够简化书写并且提高易读性的时候才使用新的返回类型后置语法. 但是后一种情况一般来说是很少见的, 大部分时候都出现在相当复杂的模板代码中, 而多数情况下不鼓励写这样 复杂的模板代码.

## 来自Google的奇技
* 动态分配出的对象最好有单一且固定的所有主, 并通过智能指针传递所有权.
* 使用 cpplint.py 检查风格错误.

## 其他 C++ 特性
* 只在定义移动构造函数与移动赋值操作时使用右值引用. 不要使用 std::forward.
* 我们不允许使用变长数组和 alloca().  (改用更安全的分配器（allocator），就像 std::vector 或 std::unique_ptr<T[]>.)
* 我们允许合理的使用友元类及友元函数.
* 我们不使用 C++ 异常.  (Google 禁止使用异常这一点, 仅仅是为了自身的方便, 说大了, 无非是基于软件管理成本上, 实际使用中还是自己决定)
* 我们禁止使用 RTTI.
* 使用 C++ 的类型转换, 如 static_cast<>(). 不要使用 int y = (int)x 或 int y = int(x) 等转换方式;    (即：不要使用 C 风格类型转换. 而应该使用 C++ 风格.)
* 不要使用流, 除非是日志接口需要. 使用 printf 之类的代替.使用流还有很多利弊, 但代码一致性胜过一切. 不要在代码中使用流.
* 对于迭代器和其他模板对象使用前缀形式 (++i) 的自增, 自减运算符.   (对简单数值 (非对象), 两种都无所谓. 对迭代器和模板类型, 使用前置自增 (自减).)
* 我们强烈建议你在任何可能的情况下都要使用 const. 此外有时改用 C++11 推出的 constexpr 更好。
* 在 C++11 里，用 constexpr 来定义真正的常量，或实现常量初始化。
* C++ 没有指定整型的大小. 通常人们假定 short 是 16 位, int 是 32 位, long 是 32 位, long long 是 64 位.    (<stdint.h> 定义了 int16_t, uint32_t, int64_t 等整型, 在需要确保整型大小时可以使用它们代替 short, unsigned long long 等.)
* 代码应该对 64 位和 32 位系统友好. 处理打印, 比较, 结构体对齐时应切记:
* 使用宏时要非常谨慎, 尽量以内联函数, 枚举和常量代替之.
* 整数用 0, 实数用 0.0, 指针用 nullptr 或 NULL, 字符 (串) 用 '\0'.
* 尽可能用 sizeof(varname) 代替 sizeof(type).
* 用 auto 绕过烦琐的类型名，只要可读性好就继续用，别用在局部变量之外的地方。
* 你可以用列表初始化。  (千万别直接列表初始化 auto 变量，)
* 适当使用 lambda 表达式。别用默认 lambda 捕获，所有捕获都要显式写出来。
* 不要使用复杂的模板编程
* 只使用 Boost 中被认可的库.
* 适当用 C++11（前身是 C++0x）的库和语言扩展，在贵项目用 C++11 特性前三思可移植性。

## 命名约定
最重要的一致性规则是命名管理.命名的风格能让我们在不需要去查找类型声明的条件下快速地了解某个名字代表的含义: 类型, 变量, 函数, 常量, 宏, 等等, 甚至我们大脑中的模式匹配引擎非常依赖这些命名规则
* 函数命名, 变量命名, 文件命名要有描述性; 少用缩写.  （一些特定的广为人知的缩写是允许的, 例如用 i 表示迭代变量和用 T 表示模板参数.）
* 文件名要全部小写, 可以包含下划线 (_) 或连字符 (-), 依照项目的约定. 如果没有约定, 那么 “_” 更好.    (定义类时文件名一般成对出现, 如 foo_bar.h 和 foo_bar.cc, 对应于类 FooBar.)
* 所有类型命名 —— 类, 结构体, 类型定义 (typedef), 枚举, 类型模板参数 —— 均使用相同约定, 即以大写字母开始, 每个单词首字母均大写, 不包含下划线. 
* 变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 但结构体的就不用, 如: a_local_variable, a_struct_data_member, a_class_data_member_.
* 声明为 constexpr 或 const 的变量, 或在程序运行期间其值始终保持不变的, 命名时以 “k” 开头, 大小写混合.  ("k"取const发音)
* 常规函数使用大小写混合, 取值和设值函数则要求与变量名匹配: MyExcitingFunction(), MyExcitingMethod(), my_exciting_member_variable(), set_my_exciting_member_variable().
* 命名空间以小写字母命名. 最高级命名空间的名字取决于项目名称. 要注意避免嵌套命名空间的名字之间和常见的顶级命名空间的名字之间发生冲突.
* 枚举的命名应当和 常量 或 宏 一致: kEnumName 或是 ENUM_NAME.  （优先选择常量风格的命名方式）
* 通常 不应该 使用宏. 如果不得不用, 其命名全部大写, 使用下划线
* 命名规则的特例  （？没看懂）

## 注释
如何注释以及在哪儿注释？当然，注释固然很重要, 但最好的代码应当本身就是文档. 有意义的类型名和变量名, 要远胜过要用注释解释的含糊不清的名字.
* // 或 /* */ 都可以; 但 // 更 常用. 要在如何注释及注释风格上确保统一.
* 文件都需要文件注释.  （如果一个文件只声明, 或实现, 或测试了一个对象, 并且这个对象已经在它的声明处进行了详细的注释, 那么就没必要再加上文件注释.不要在 .h 和 .cc 之间复制注释, 这样的注释偏离了注释的实际意义.）
* 每个类的定义都要附带一份注释, 描述类的功能和用法, 除非它的功能相当明显.  （如果类的声明和定义分开了(例如分别放在了 .h 和 .cc 文件中), 此时, 描述类用法的注释应当和接口定义放在一起, 描述类的操作和实现的注释应当和实现放在一起.）
* 函数声明处的注释描述函数功能; 定义处的注释描述函数实现.  （注释使用叙述式 (“Opens the file”) 而非指令式 (“Open the file”); ）
* 通常变量名本身足以很好说明变量用途. 某些情况下, 也需要额外的注释说明.  （特别地, 如果变量可以接受 NULL 或 -1 等警戒值, 须加以说明）
* 对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释.  （代码前注释、行注释、函数参数注释、不允许的行为）
* 注意标点, 拼写和语法; 写的好的注释比差的要易读的多.
* 对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用 TODO 注释.  （如果加 TODO 是为了在 “将来某一天做某事”, 可以附上一个非常明确的时间）

##格式
* 每一行代码字符数不超过 80.  （如果无法在不伤害易读性的条件下进行断行, 那么注释行可以超过 80 个字符, 这样可以方便复制粘贴. ）
* 尽量不使用非 ASCII 字符, 使用时必须使用 UTF-8 编码.
* 只使用空格, 每次缩进 2 个空格.
* 返回类型和函数名在同一行, 参数也尽量放在同一行, 如果放不下就对形参分行, 分行方式与 函数调用 一致.
    1、右圆括号和左大括号间总是有一个空格.  
    2、未被使用的参数, 或者根据上下文很容易看出其用途的参数, 可以省略参数名: 
    3、未被使用的参数如果其用途不明显的话, 在函数定义处将参数名注释起来:）
* Lambda 表达式对形参和函数体的格式化和其他函数一致; 捕获列表同理, 表项用逗号隔开.
* 要么一行写完函数调用, 要么在圆括号里对参数分行, 要么参数另起一行且缩进四格. 如果没有其它顾虑的话, 尽可能精简行数, 比如把多个参数适当地放在同一行里.
* 您平时怎么格式化函数调用, 就怎么格式化 列表初始化.
* 倾向于不在圆括号内使用空格. 关键字 if 和 else 另起一行.  （注意所有情况下 if 和左圆括号间都有个空格. 右圆括号和左大括号之间也要有个空格:）
* switch 语句可以使用大括号分段, 以表明 cases 之间不是连在一起的. 在单语句循环里, 括号可用可不用. 空循环体应使用 {} 或 continue.
* 句点或箭头前后不要有空格. 指针/地址操作符 (*, &) 之后不能有空格.  （在声明指针变量或参数时, 星号与类型或变量名紧挨都可以:原则是：单个文件内要保持风格一致,）
* 如果一个布尔表达式超过 标准行宽, 断行方式要统一一下.  （直接用符号形式的操作符, 比如 && 和 ~, 不要用词语形式的 and 和 compl.）
* 不要在 return 表达式里加上非必须的圆括号.
* 用 =, () 和 {} 均可.  （请务必小心列表初始化 {...} 用 std::initializer_list 构造函数初始化出的类型. ）
* 预处理指令不要缩进, 从行首开始.  （即使预处理指令位于缩进代码块中, 指令也应从行首开始.）
* 访问控制块的声明依次序是 public:, protected:, private:, 每个都缩进 1 个空格.
    1、这些关键词后不要保留空行.
    2、public 放在最前面, 然后是 protected, 最后是 private
* 构造函数初始化列表放在同一行或按四格缩进并排多行.
* 命名空间内容不缩进.  （声明嵌套命名空间时, 每个命名空间都独立成行.）
* 水平留白的使用根据在代码中的位置决定. 永远不要在行尾添加没意义的留白.  （继承与初始化列表中的冒号前后恒有空格.  对于单行函数的实现, 在大括号内加上空格）
* 垂直留白越少越好.

##规则特例
* 对于现有不符合既定编程风格的代码可以网开一面.

##结束语
* 运用常识和判断力, 并且 保持一致.