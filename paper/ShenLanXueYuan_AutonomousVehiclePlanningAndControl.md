# Autonomous Vehicle Planning and Control
## 4. Vehicle Lateral Optimal Control
### 第1节：车辆动力学模型
1. 车辆运动学、动力学的应用区别。
运动学：低速、
动力学：高速、轮胎与相应部件的受力情况、平顺性（悬架系统，z轴）、操作稳定性（车轮轮胎模型，x、y轴）
2. 自行车模型在“运动学”、“动力学”下分析有如下不同点：
* 速度的不同：
  1. “运动学”在转弯时，前轮速度Vf方向朝向弯道内侧，后轮速度Vr方向为车辆轴向方向。（后轮不可转向）
  2. “动力学”其前后轮的速度Vf、Vr方向是不相同的，前轮朝内，后轮朝外，但前后轮速度矢量和的方向一定朝向转弯侧。（后轮不可转向）
  3. 算出的前后轮受力，前轮Fyf = 2Cf(δ-θvf)；后轮Fyr = 2Cr(-θvr)。所以后轮受力计算中会有一个符号‘-’；（以深蓝的课件看，角度逆时针为正）。
  4. 由“运动学”推出来：前轮的转弯半径Rf > 后轮转弯半径Rr(直角三角形，斜边大于直角边);但是由轮胎动力学推推理出来，前轮的转弯半径Rf < 后轮转弯半径Rr(前轮速度方向朝转向圆内侧，后轮速度方向朝转向圆外侧)。
> 注：
> 上述4种情况都在正常后轮不可转向的前提下分析，当后轮可以转向时，分析方式有所不同。
> 深蓝Session 4图Dynamic Bicycle Model自行车模型受力分析有错误的地方（1）Fyf、Fyr、v三者以及相应的分量的方向画错了；（2）角度θ以逆时针为正，但是横摆角速度φ_dot却以顺时针为正，有点乱。
> 课件的动力学模型有整体的受力分析，但是《Vehicle Dynamics and Control》中没有。虽然前者虽然有错误，但也更好理解一点。
3. 车辆横纵向动力学模型建模有4个假设：
  * Longitudinal velocity is constant,
  * Left and right axle are lumped into a single wheel(bicycle model).
  * Suspension movement, road inclination and aerodynamic influences are neglected,
  * Decoupled longitudinal and lateral motion.
4. Linearized dynamic bicycle model中Applying small angle assumptions，cos(δ)≈1、cos(δ)≈0、tan-1(θ)≈θ，这3个不合适吧？因为转向角δ还没有小到这种程度（最大转角30度）。通过这个步骤，将非线性系统线性化了（就是想办法，将非线性系统中的非线性因素，换成线性因素）。
5. 车辆模型参数的时别：
  1. 4个轮子下放4个秤，可获取车辆质心参数；
  2. 轮胎刚度的图怎么看：根据车重确定法向力，再获取相应法向力下轮胎的测偏刚度。（没有轮胎参数时，也可以自己通过欧拉法的最小二乘问题来求解轮胎刚度。）
### 第2节：线性系统优化
1. 代价函数
* “The objective is to bring the non-zero initial state to zero in the infinite time horizon.”这句话说明代价函数要最终可积，且最终可以求出结果，那么就要求把状态最终调节到0。因此，状态x定义是“状态偏差、状态偏差变化率”（而不是“状态”，因为系统运行时状态一定不是为0的）。因此，这句话的意思是，将一个与预期有偏差的系统，变为与预期无偏差的系统（即偏差为0）过程中，状态偏差的平方、输入的平方和的累加，就是最终的代价cost。（即J）
* J数值越大越要排除。（说明状态变化的越剧烈、或者说明最终维持误差为0所需要的输入越大。）
* 为什么是“二次型”：（课件P32说明了这一点，积分平方误差指数（ISE））
  1. 因为代价函数中的误差、误差变化率可能为正或者负，而不管正负，都是系统状态的抖动或者消耗，都是不想要的。因此要求平方后，再累加，才能更好的求出整个系统作用过程中，状态误差、输入u的累计最小。因此要对x、u取平方后再累加。
  2. 因为二次型函数是凸函数，一定具有局部最小值。（即一定可解）
* J的表达式中，将Q、R矩阵放在中间，是因为J最终算出来的是标量，而把Q、R放在边上的话，那Q、R就也是标量了。如果要对向量x、u中的每个元素都考虑的话，就需要使用矩阵所谓权重系数，矩阵中的每个元素，对应向量x、u中每个元素的权重。
* 为什么Q、R是对角矩阵：因为对角矩阵才能把状态向量x中的每个元素x<sub>i</sub>的权重给单独拎出来，而不用耦合在一起。（见课件p31）
* Q、R对角线上元素值的选择：例如状态向量x为[e1,e2,e3,e4]，Q矩阵对角线上4个元素分别是q1,q2,q3,q4，那么q1越大，说明对e1的惩罚越大，说明实际调节过程中，越在意这个状态e1，希望e1一直维持在最小的水平。（实际对应到车上来讲，我会希望车辆实际运行时，lat_err、head_err小一点，lat_err_rate、head_err_rate大一点也没关系，那么我应该把q1,q3设大一点，q2,q4设小一点。）
* Q、R值的设置：
  1. 权重Q、R的数值大小不重要，Q与R比例最重要，只要比例相同了，就能选出相同的结果。（虽然Q、R的数值决定了算出的代价值大小不同，但是最终要的不是代价值的具体数值，而是这个代价值的大小关系。即我只要知道谁是最小的就行了。而选出谁是最小的，这也是最终的目的。）
  2. 同样Q、R矩阵内部元素间也是比例关系最重要。
  3. Q >= 0, R > 0.说明，一定要有输入才能保证系统的运行。（这与真实世界也一致）
  4. 因此，实际调参过程是将R矩阵置为1，然后去调节Q矩阵的大小。
2. a scalar example
* 对于J存在最小值的条件是：J对K的一阶导 = 0，对K的二阶导 >= 0。（这一点不理解？！）
3. LQR: General Solution
* 通用LQR的求解过程有以下6个关键点：
  1. 假设在“控制率”为K的闭环反馈下，系统是稳定的，此时u = -Kx;
  2. 如果J是收敛的，那么"误差状态量x、输入量u"在"t->∞"时，x(∞)=0,u(∞)=0;
  3. 假设矩阵P的存在；
  4. 一个二次型方程横等于0，那么其系数一定等于0；
  5. 根据方程形式，设 K = R<sup>−1</sup>BTP（这里就不时假设了），此时推导出关于矩阵P一个未知量的方程（Raccati），P可求解，说明假设3成立；假设1系统稳定也成立。
  6. Raccati方程的求解方式，迭代法。（这是不是矩阵方程的唯一求解方式呢？待明确。）
4. Case study: LQR tuning
* 固定Q，调节R时，只要执行器对输入不饱和时，就选小的R；如果饱和了，就选大点的R。（因为Q一定时，R越小，使用输入越多，状态响应越快。）
> 换句话说：就是R越大，要求输入u（输入）越小（反比关系）；而R越大时相对Q就小了，此时要求误差x越大（即响应越慢），即R大时，输入小、响应慢。（反之，R小时输入大、无差小<响应快>）
* 固定R，调节Q。此时一般也是先固定Q中的一个参数q*，在调节其他q。但是q*除了影响q*与q的比值外，也影响了Q与R比值。
5. lqr状态空间的设计，涉及的知识有：
* 自动控制系统中，控制方式主要有2种：反馈、前馈；
* “反馈”在状态空间的设计中有2种方法：状态反馈、输出反馈；（lqr中设“u=-Kx”就是状态反馈）
* “状态反馈、输出反馈”分别对应不同嗯的系统结构图。
* “状态反馈”控制率为：u = r - Kx,其中r为参考输入，K为状态反馈矩阵。
* 经过状态反馈后，矩阵𝑩, 𝑪没有发生变化，仅仅是矩阵𝑨发生了变化，但矩阵𝑨的变化并没有引入新的状态变量，也没有增加系统的维数。同时，我们可以选择𝑲自由地改变闭环系统的特征值，从而使系统达到所要求的性能。
### 第3节：离散化（dlqr）
* “零阶保持器”实现离散化；
* lqr离散化的过程可以不关注，只需关注以下6个关键的求解步骤，即可使用lqr进行求解：
  1. A的离散化矩阵Ad的求法；
  2. B的离散化矩阵Bd的求法；
  3. Q、R矩阵不需要离散化；
  4. 离散化Raccati方程的求解，求出矩阵P；(迭代法求解，可以使用warm start的方式，求解更快)
  5. 求解K矩阵；（利用矩阵a、b、r、p求解K。此处的a、b、r、p都不用离散化）
  6. 利用u = -Kx求解反馈输入。
### 第4节：基于LQR的轨迹追踪
* 基于LQR轨迹跟踪的求解过程：
  1. 根据系统构建基于误差的状态空间方程。（因为lqr的目标函数J就是要把误差优化到0，所以直接列出的是“误差模型”）
  2. 根据状态空间方程中的系数矩阵，判断系统时不时可控的。（满秩[B<sub>1</sub>,AB<sub>1</sub>,A<sup>2</sup>B<sub>1</sub>,A<sup>3</sup>B<sub>1</sub>]）
  3. 再使用“第3节 离散化”的内容去求解。
* 为什么将基于**车辆坐标系**的车辆状态空间方程，转到基于**道路Frenet坐标系**下呢？答案如下：（汉鹏之前提过）
  Curvy road performance is not that good. The dynamic bicycle model approximates the lateral dynamics of the vehicle, but in order to enable the use of linear control techniques the path coordinate model is linearized about the forward direction. In other words, the model excludes the non-linear path dynamics and best approximates a vehicle following a straight path.
### 第5节：基于preview的轨迹追踪（多点lqr）
* 先列出车辆的横向动力学模型方程。（“横向动力学模型”区别于“横向误差模型”）
* 建立道路预瞄模型方程。（the reference path preview model）
* 增益模型建立：
  1. 先通过矩阵合并，建立关于**车辆动力学模型**与**道路预瞄模型**的状态方程；
  2. 再通过二次优化的目标函数，将于**车辆动力学模型**与**道路预瞄模型**复合起来求解；
* 多点lqr的调参与适用场景
  1. Q is heavier: Use case: For environments with strict constraints, such as static obstacle, narrow road with curb.
  2. R<sub>2</sub> is heavy: Use case: Highway driving.
### 第6节：轨迹追踪方法的总结
* 4个比较维度：跟踪精度（超调）、对轨迹质量要求（连续性、平滑性等）、鲁棒性（抗干扰能力）、适用场景。
参照课件第64页。


























